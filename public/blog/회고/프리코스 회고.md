---
title: 
date: 2024-01-18
tags: 
image: 
summary: 
published: false
---

## 우테코 운영진의 메세지

인생을 살면서 숱한 시험을 봤지만 테스트 시작 전에 이런 따뜻한 메세지를 받아본 것은 이번이 처음인 것 같다.

> “안 돌아가는 프로그램보다 돌아가는 쓰레기를 만들어도 괜찮아요.” “그간 고생 많으셨고 최종 코딩 테스트가 끝난 후 푹 쉬시길 바랍니다.”

수요일에 테스트 명단이 발표되고 나서 줄곧 긴장상태를 유지했었습니다. 시험 보기전에 이 메세지 덕분에 테스트라기 보다는 5차 미션이라고 생각하자고 마음을 다잡은 것 같습니다. 내가 이 프로그램의 주인이라 생각하고 재밌게 코드를 짜보자는 생각을 하면서 자연스레 긴장이 많이 풀린 것 같습니다.

따뜻한 메세지도 좋았지만, 테스트가 끝난 이후에도 제 머리에 계속 남아있던 말이 있었습니다.

_**“이상과 현실의 경계에 놓인 이번 최종 코딩 테스트를 시험이 아닌 또 다른 교육으로 생각하며 즐겨 보시길 바랍니다.”**_

테스트를 치루기 전에는 단순히 이번 미션이 선발을 위한 테스트라고만 생각을 했고, 이는 매우 특수한 환경이라고 생각했습니다. 5시간 안에 미션 하나를 구현시키는 것은 제가 이제껏 미션을 해왔던 환경과 비교했을 때 **매우 제약적**이기 때문입니다.

하지만 **“오히려 미션을 일주일동안 구현했던 것이 특수한 환경이지 않을까?**” 5시간 안에 미션을 해결하는 것이 더 일반적인 상황이라 생각을 했습니다. 현업에서도 주어진 시간안에 빠르게 요구사항을 충족시켜야하는 상황의 연속일 것이라는 가정을 해보면, 이번 최종테스트가 더욱 일반적이고 현업에 가까운 환경일 것입니다. 즉, 제가 공부하고 있던 환경 자체가 이상적인 상황이지 않았을까 생각하게 되었습니다.

이렇게 생각을 고쳐보니, 5시간 안에 내가 제대로 이행하지 못하고 헤매었던 부분에 더 생각을 해볼 필요를 느꼈습니다. **애매하게 아는 것들, 즉, 충분히 고민하지 않았던 부분은 결국 제한된 시간에 적재적소에 적용할 수 없기 때문입니다.**

# 🌳 제대로 사용할 수 없다면, 충분히 생각하지 않았던 것

## 🌿 객체지향 - 은닉화

객체 지향에서 모든 객체는 은닉화와 캡슐화를 지켜야합니다. 그래야 변화에 대한 격리가 가능하고 객체마다 책임을 분명히 둘 수 있기 때문입니다. 하지만 이를 아는 데 도저히 적절한 방법이 떠오르지 않았습니다.

```jsx
//제 짠 코드입니다.

class Coach {
  #name;

  getName() {
    return this.#name;
  }
}
```

바로 이 getName 메소드입니다. 객체의 속성은 은닉은 하고 싶지만, getName()메소드는 추상화라곤 하나도 없이 자신의 속성을 그대로 반환하는 역할을 하고 있습니다. **이상과 현실의 괴리를 잘 보여주는 코드인 것 같습니다.**

사실 이에 대한 고민은 Lotto 게임(2주차미션)을 다시 풀어보면서 접한 문제이기도 했습니다. WinningNumber와 Lotto를 모두 객체로 만들었습니다. 여기서 생긴 문제는 당첨 여부를 확인하려면 서로의 속성을 모두 알고 있어야 합니다. 이 부분에서 은닉이 깨지는 걸 제대로 해결하지 못 했던 것 같습니다.

## 🌿 객체 참조

모델에서 Coach 객체를 담고 있는 리스트를 속성으로 갖고 있었습니다. 그리고 이를 Controller에 넘겨서 배열에서 하나씩 빼면서 InputView에서 `(코치이름) 이(가) 못 먹는 음식` 이 무엇인지 물어보는 로직을 만들었습니다. 이에 대한 문제를 제대로 인지하지 못한 채 계속 코드를 작성하다가 시간을 많이 소비했습니다.

Controller에서 모델이 소유하고 있는 리스트에서 요소를 하나씩 뺀다는 것은 같은 메모리 주소를 참조하고 있기 때문에 모델에서도 요소가 빠진다는 것입니다. 즉, 코치별로 못 먹는 음식을 입력을 받고 나면 모델에 저장한 코치들이 다 사라지는 기이한 현상이 발생합니다 . (정말 웃픈 상황 😂 )

분명 프리코스가 끝난 뒤에 value context와 reference context에 대해 공부를 했었습니다. 그리고 함수형 프로그래밍에서 값이 아닌 객체를 인자로 받을 때는 반드시 복사본을 사용한다는 것도 이해했었죠. 하지만 반대로 객체지향에서 참조가 아닌 복사본을 보내줘야할 때를 제대로 생각해보지 않은 것 같습니다. 객체 지향은 반드시 참조를 같이 해야한다고만 은연 중에 공식처럼 여겼던 것 같습니다. (추가로 스프레드 연산자를 통해 값을 복사했는데, 배열에 있는 객체의 속성값이 배열인 경우에는 값이 계속 참조된다는 것이 떠올랐습니다. 온전히 값으로서 객체를 전해준 것 같진 않습니다. )

저의 경우는 Coach 리스트를 넘길 때 복사본을 넘기는 방식으로 이를 해결했지만, 반대로 생각해보면 Controller에서 리스트를 하나씩 빼는 방법이 아닌 다른 로직으로 풀면 참조를 유지하면서 문제를 해결할 수 있겠다는 생각도 듭니다. 이 또한 충분히 생각할 필요가 있어보입니다.

## 🌿 테스트코드

아마 이 부분은 테스트를 보신 많은 분들이 공감하실 것 같습니다. (혹시 저만 이랬던 건 … 아니겠죠? )

A: “카테고리 중복, 음식도 중복되어서 안 나오고, 깔끔하게 출력 되는 것 같은데 왜 테스트가 제대로 작동하지 않는거야!! 테케에서 출력조차 되질 않아…ㅠ”

B: “너 테스트 코드를 제대로 안봤구나?”

A: “무슨 말이야! 요구사항에는 그런 말 없단 말이야!”

B: “테스트 코드를 제대로 봤어야지! `const sequenced = (*_*, *idx*) => *idx* + 1` 메뉴 리스트도 1부터 시작이야! 호호 ”

A: “요구사항만 보고 카테고리만 1부터인 줄 알았어 ㅠㅠ”

시험 끝나고 테스트 코드를 작성하지 못 한 사항에 대해서 혼자 1인 2역으로 뜯어 보면서 “외않되???”를 반복하면서 제가 제대로 테스트코드를 보지 못 한 불찰에 대해 깊이 반성했습니다. 😂

⭐ **하지만 지금 회고를 작성하는 시점에서 제 코드에 그것 말고 문제가 하나 더 있었습니다**. 주어진 테스트 코드에서 mockShuffles 함수를 통해 MissionUtils.Random.shuffle의 리턴값을 지정해주었는데, 왜 제 코드에서는 shuffle을 통해 반환된 인덱스 값이 주어진 거와 다르게 반환되는 지 확인해봐야할 것 같습니다.

**(2022.12.20 해결됨)**

---

### 문제 사항

- 요구사항: 카테고리를 하나 정할 때마다 코치 한명씩 음식을 추천해주는 방식
- 테스트코드: 카데고리 5개를 정한 다음 코치 한명씩 돌아가면서 음식 5개를 한번에 추천해주는 방식

### 생각하기

정말 제가 해결하지 못했던 마지막까지 많은 생각을 하게 해주는 것 같습니다. (최종 코딩테스트에서도 수수께끼 풀듯 생각할 거리를 심어놓으신 것 같습니다.)

1. 요구사항과 테스트코드가 다르다면 무엇을 따라야할까?
    
    이 부분은 요구사항을 맞추는 것이 맞는 것 같습니다. 테스트코드는 요구사항을 잘 지키기 위한 도구이기 때문입니다.
    
2. **하지만 이번 문제는 요구사항에 기재된 로직과 테스트코드에서 요구하는 로직에서 결과의 차이가 없다면?**
    
    **이 둘의 결과에 차이가 없다면 냉정하게 어떤 로직이 더 좋은지 고민을 해봐야 합니다.**
    
    사실 문제 처음 접했을 때에도 카테고리를 먼저 다 고르고 한명씩 돌아가면서 5개의 메뉴를 추천해주는 것이 편리해보였습니다. **왜냐하면 카테고리를 정하는 코드를 다 마친 다음 데이터를 넘겨주어 다음 요리를 추천해주는 것이 코드에서 역할 구분이 명확합니다.** 즉 가독성도 좋고 유지보수에도 더 편할 것입니다. 하지만 제가 짠 방식인 카테고리 하나를 고를 때마다 음식을 추천해주는 과정은 중첩 반복을 하는 과정이기에 호흡이 길고 테스트하기에도, 유지보수에도 좋지 않은 것 같습니다.
    
    목적만 정확히 파악하고 부수효과만 없다면 더 좋은 코드, 더 좋은 로직을 만들어 내는 것이 개발자의 역할이 아닌가 생각해보는 계기가 되었습니다.
    

## 🌿 입력값 파싱

이전 프리코스 미션에서 저만의 룰이 있었습니다. 유저가 값을 입력할 때 “,”를 기준으로 값을 구분합니다. 하지만 띄어쓰기 정도는 유저가 잘못 입력할 수도 있으니 이 부분은 코드에서 공백을 제거해서 검증하자는 것입니다. 그래서 이번에도 공백을 다 제거한 다음에 “,”를 기준으로 값을 분리했습니다.

입력에 대한 깊은 고민이 없었기 때문에 당연하게 이렇게 하면 된다고 공식처럼 머릿 속에 각인되었던 것 같습니다. 이 문제의 경우에는 메뉴 자체에 공백이 있는 경우가 있기 때문에 기존의 방식으로는 제대로 처리할 수 없습니다. “토마토 달걀볶음”의 경우 공백이 제거되기 때문에 “토마토달걀볶음”이 되어버리기 때문입니다.

뒤늦게 이 사실을 깨닫게 되어서 SAMPLE 데이터에서 문자열을 배열로 바꾸는 과정에서 “, ”를 “,”로 변경 후에 split해주는 방식으로 변경하여 해결했습니다. 하지만 미처 입력 상황까지는 생각하지 못 했습니다.

입력 상황에서는 이를 해결하려도 보니 “,”로 먼저 구분(split)을 한 다음에 배열 요소를 루프 돌면서 trim하는 것이 더 명확하고 확실하다는 생각이라는 것을 알게 되었습니다.

`input.split(',').map((*elem*) => *elem*.trim())`

# 🌳 나는 어떻게 성장했을까

## 🌿 회고 글에 실수한 것만 나열한 것 같습니다.

**나는 정말 말을 잘 듣는 타입이라 “코딩 테스트가 끝난 후 푹 쉬시길 바랍니다.” 이 말을 최선을 다해서 지키려고 했습니다.** 그럼에도 영화 볼 때도, 유튜브를 볼 때도, 심지어 잠을 잘 때도 ‘이런 값이 들어온다면?’ , ‘혹시 여기에서 문제가 생긴다면? 등등 내가 짠 코드에 계속 고민을 하게되고 부족한 점이 생각이 떠올랐습니다. 일요일에는 정말 코드 한줄도 안 읽었지만 내 머릿 속에서 문제를 계속 찾고 있었고, 심지어 찾았습니다… (그럴 수록 더 슬퍼져! 하지마…)

이왕 이렇게 된 거 그냥 내가 떠올렸던 더 보완해야하는 점들을 까먹기 전에 정리를 해야겠다는 생각에 내가 미처 생각하지 못 하거나 실수를 한 것들 위주로 먼저 서술해 놓았습니다.

## 🌿 이 부분은 잘했다!

부족하고 개선할 점을 회고하는 것이 필요한 만큼 내가 이만큼 성장했고 이런 것들은 잘 지켜서 코딩을 했다는 점도 적어 높으면 좋을 것 같다는 생각에 정리해보려 합니다.

- 드디어 미션에서 함수를 반환하는 고차함수를 적용해보았다!
    
    ```jsx
    class Controller {
    
    	//...
    	#handleSettingCannotEat(coachList) {
        return (menusCannotEat) => {
    	      //...
    		};
    	}
    }
    
    //실행부
    this.#inputView.readCannotEat(coachList[0], this.#handleSettingCannotEat(coachList).bind(this));
    ```
    
    코치 리스트를 캡쳐링하여 콜백으로 넘겨주어야했습니다. 캡쳐링할 데이터를 인자로 받아서 함수를 반환함으로써 콜백 함수를 다른 함수의 인자로 넣을 수 있었습니다. (클로저 활용)
    
- 재귀 오류 없이 잘 사용했다!
    
    항상 재귀가 어려웠습니다. 특히 4주차 미션에서는 잘못된 입력일 경우 해당 시점부터 다시 입력을 받아야했습니다. 제대로 입력이 될 때까지 재귀를 돌아야했습니다. 처음에는 잘 그려지지 않았는데 프리코스 끝나고 재귀를 틈틈이 공부했던 것이 도움이 되었습니다. 이번 최종 테스트에서는 입력뿐만 아니라 메뉴를 선정할 때도 이미 있는 메뉴와 싫어하는 메뉴를 고르지 않을 때까지 무작위로 섞어야 했습니다. 재귀를 사용할 때 오류가 나면 정말 디버깅하기 힘들었는데 오류 없이 잘 작동시켰습니다.
    
- 예외처리 노력했다!
    
    모든 부분을 깔끔하고 꼼꼼하게 예외 처리했는지는 확신할 수 없습니다. 항상 예기치 않은 답변이 있기 때문입니다. 그럼에도 제가 고려할 수 있는 한에서는 최대한 예외처리를 해보았습니다. 코치 이름이나 못 먹는 메뉴 이름을 중복해서 적은 경우를 포함해서 말이죠.
    

## 🌿 프리코스부터 지금까지 “고민”했던 것들

잘한 부분을 읽다보니 예전에 고민했던 기억이 떠올랐습니다. 프리코스 때 작성했던 코드나 회고를 읽으면 제가 그 당시 어떤 고민을 했는가를 추적해보려고 합니다. (오늘만큼은 추억에 젖어보자!)

### 1주차

정말 욕심이 그~득하고 패기 넘쳤던 것 같습니다. 그 당시 함수형 프로그래밍을 적용해보고 싶어서 어떻게든 메소드를 체이닝으로 엮어서 구현했습니다. 그러면서 마지막 문제는 규모가 있다보니 객체를 활용해서 구현하고 싶어서 열심히 객체지향 찾아보면서 구현했던 것 같습니다.

1차 회고 때 있었던 내용이 정말 재밌었습니다.

![1주차 회고 내용](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d19bf325-4e78-435e-932b-cbeb6b60914d/Untitled.png)

1주차 회고 내용

1주차때 객체 지향을 공부하면서 헷갈렸던 개념을 정리했었는데요. **정말 제가 시험 보기 전까지도 고민했던 내용들이라 신기했습니다.** 과거의 나에게 말을 건널 수 있다면 “니가 고민하는 것들은 처음해서 어려운 게 아니라 원래 어려운거야.” 라고 말해주고 싶네요. 왜냐하면 이 모든 궁금증을 아직도 찾아보고 있고 고민하고 있으니까요!

그 외에도 solution 메소드에 사용할 것들을 밖에 선언해도 되는가? for문은 사용을 지양해야하는가? 등의 고민도 많이 했었습니다.

### 2주차

2주차는 정말 혼쭐이 났던 주차였습니다. 기본적인 모듈부터 비동기, 테스트코드, eslint 등 모르는 개념들이 대거 출몰했기 때문입니다. 자바스크립트 모듈을 분리하는 기준도 잘 몰랐을 뿐만 아니라 외부 라이브러리를 import 가 되지 않아 답답하기도 했습니다.

또한 Console.readLine()이 비동기로 작동한다는 것도 모르고 뭐가 문제일까 엄청 해맸습니다. 비동기라는 것을 알고 열심히 await async까지 공부를 했고, 함수의 역할을 분명히 하기 위해 promise를 사용했는데 테스트코드는 이를 받아주지 않았죠. 정말 2주차는 “제발 돌아가게만 해주세요!” 컴퓨터에게 빌면서 코드를 짰던 것 같습니다.

정말 다행이었던 것은 2주차가 끝난 뒤에 크루들과 Discussion에서 이야기를 나누면서 제가 했던 고민들을 크루들도 비슷하게 했다는 것입니다. 그래서 서로 경험담을 공유하면서 비동기일 때는 테스트코드를 다르게 작성해야한다는 것도 알게 되었습니다.

### 3주차

2주차의 폭풍이 지나가고 나니 미션의 공통된 부분이 보였습니다. 입력을 받을 때는 콜백으로 로직을 이어가야한다는 것입니다. 때문에 오직 코드 작성에만 집중할 수 있었던 주차였습니다. 여유가 생겼는지 [자바스크립트 코딩의 기술]이라는 책을 읽기도 했습니다. 또한 객체를 분류하는 기준에 대해 찾아보면서 MVC 패턴에 대해 공부를 했습니다. 계속 찾아보는 데도 MVC와 OOP을 정확히 구현하는 방법을 모르겠다는 생각을 했었습니다. 그래서 최대한 현실에 빗대어서 객체를 만들었습니다. 예를 들면, 로또 주최자, 구매자 이런 식으로 객체를 나눠서 소임을 주었죠.

### 4주차

4주차는 미션보다도 3주차에 받았던 피드백 내용을 많이 고민했던 주차였습니다. “객체스럽다?” “메세지를 통해?” “테스트하기 좋은 코드?” 빨리 구현은 하고 싶은데 피드백도 적용하고 싶고, 동시에 피드백이 이해가 안되는 그런 난처한 상황이었습니다. 어찌되었던 구현을 완료해야했기 때문에 제 나름 이해한 것을 바탕으로 코드를 작성했던 것 같습니다.

또한 MVC 패턴에 대해 정말 많이 공부할 수 있는 기회였습니다. 특히 운영진께서 객체를 선언을 해줌으로써 틀을 잡아주셨기 때문에 3주차 때 어려웠던 구조를 잡는 데에 많은 도움이 되었습니다. 그리고 4주차는 오히려 미션을 할 때보다 미션이 끝나고 더 깊은 고민을 하게 된 주차였습니다. 왜냐하면 다른 크루분들의 코드에서 배울 점이 정말 많았기 때문입니다.

### 프리코스 이후

프리코스 이후 가장 제게 가장 생각을 많이 한 부분은 “객체 지향”입니다. 저 딴에는 객체를 나눠서 각자의 소임을 줬다고 생각했습니다. 그런데 다른 크루분들의 4주차 미션 구현한 것을 보니 잘 하시는 분들은 객체를 정말 많이 나눠놓으셨습니다. 처음 봤을 때는 “이렇게까지 세부적으로 객체를 많이 나눠 놓는 것이 맞는건가?” 라는 생각을 했습니다. 크루분의 코드를 제대로 이해를 못 하는 원인이 객체 지향을 제대로 이해하지 못한 것에서 시작한다 생각하여 영상과 글을 많이 찾아봤습니다.

찾아보니 왜 프로그래밍에서 패러다임이 필요한지까지 알게 되었습니다. 결국 저차원의 코드는 고도의 알고리즘이 필요하고 이런 부분 때문에 Inversion of Control 이 필요하다는 것도 배웠습니다. 한 마디로 어렵고 저차원의 코드들은 모아서 고수분들이 짜야한다는 것입니다. 우리가 자바스크립트의 엔진과 문법을 뜯어고치지 않는 이유가 여기에 있는 것이겠죠. 또한 Isolation of Change. 변화에 대한 격리를 시키는 것입니다. 하나가 망가졌을 때 다른 것으로 전이되는 것을 막아야한다는 것입니다.

전반적인 프로그래밍의 패러다임에 대해 이해는 했습니다. 하지만 다시 돌아와 SOLID원칙을 공부하면서 인터페이스를 사용하는 것이 어떻게 변화를 격리시키는 것인지 전혀 감이 안 잡혔습니다. 정말 며칠을 이것만 공부한 것 같습니다. 찾아보고 이해하려 노력하면서 SOLID원칙은 결국 다 이어지는 내용이고 OOP가 어떻게 변화를 격리시킬 수 있는지 조금이나마 이해할 수 있었습니다. (제가 어느 정도 규모의 코드를 짜보기 전까지는 온전히 이해할 수 있다고 말할 수는 없을 것 같다는 생각을 했습니다.)

또한 객체지향을 공부할 수록 “변화”에 대해 집중하게 되었고 제가 짠 미션에서 하나씩 변경해봤습니다. 만약 다리 건너기 게임이 너무 잘되어서 난이도를 나누고 다리의 길이 제한을 늘린다면? 다리를 상단하단이 아니라 중단도 만든다면? **정말 하나의 변화에 따라 하나의 객체만 손을 보면 되는가**를 중심으로 제 코드를 봤습니다. 정말 자그마한 것 하나를 바꾸려니까 많은 것들을 바꿔야하는 코드를 목도해버렸습니다. 지금 제가 느끼는 생각은 제가 짠 코드가 이런 문제가 있을 것이라고 예상은 되지만 어떻게 좋게 바꿔야하는지는 캄캄한 듯 합니다.

# 🌳 끝으로

최종 테스트 결과가 어떻게 나올지 모르겠습니다. 기대도 되면서 걱정도 되기도 하여 시험을 본 이후에도 기분이 싱숭생숭합니다. 시험을 보고 나면 후련할 줄 알았는데 말입니다. 그래도 이렇게 글을 쓰면서 마음을 정돈하니 지금 해야할 것들이 명확해진 것 같습니다.

또한 프리코스부터 정말 몰입하면서 달려왔기 때문에 “해야 하는 것”과 “하고 싶은 것”을 적절히 섞으려 합니다. 이전에는 프리코스에 도움이 될 것 같은 것들 위주로 공부했거든요. 리액트랑 타입스크립트, 함수형 프로그래밍도 빨리 맛보고 싶었는데 참았거든요…

**`해야 하는 것`**

- **자료구조와 알고리즘**: 이미 한번 공부를 한 적이 있지만, 이번 최종 코테를 보면서 더 느꼈던 것 같습니다. 아키텍쳐를 생각하는 힘과 컨벤션을 지키는 습관도 중요합니다. 동시에 주요 로직을 제대로 구현할 수 있는 힘도 중요하다고 생각했습니다. 만약 최종 코딩테스트에서 재귀를 더 복잡하게 구현해야했다면 아마 제대로 못 했을 것 같다는 생각에 자료구조와 알고리즘을 공부하려 합니다.
- **컴퓨터 구조와 운영체제, JS 엔진:** 코드를 짜면서 내부적으로 어떻게 작동하는 지 머릿 속에 그려지는 게 필요하다고 느꼈습니다. 엄청난 시간이 필요할 것으로 생각되어 지금부터라 공부하고 습관을 들여야할 것 같습니다.
- **부던히 다른 사람의 코드를 읽을 것**: 미션 피어리뷰를 하면서 다른 사람의 코드를 읽는 것은 정말 쉽지 않은 것 같습니다. 그 사람이 어떤 생각을 했는지 코드를 보면서 그려야하는데 쉽지 않았습니다. 그럼에도 다른 사람의 코드를 보면서 정말 많이 배웠기 때문에 반드시 제가 익숙해져야하는 것이라 생각합니다.

**`하고 싶은 것`**

- **리액트**: 사실 프리코스 끝나고 리액트를 조금 공부해봤습니다. 예전에는 왜 상태를 관리해야하고 모듈을 나누는지 몰라서 이해하기 너무 힘들었는데, 미션 끝나고 다시 보니 리액트가 너무 재밌고 이해가 쏙쏙 되었습니다. 얼른 공부하고 싶습니다 🙂
- **타입스크립트**: 프리코스 끝나고 자바를 공부하시는 분하고 이야기할 기회가 많았는데, 항상 듣는 말이 “자바스크립트엔 이런거 없어?” 였습니다. 특히 타입과 인스턴스. 강타입 언어의 맛을 보고 싶습니다. 얼마나 매콤할까요.
- **함수형 프로그래밍**: 이것도 프리코스 끝나고 “함수형 코딩”이라는 책을 읽다가 시험 준비를 하느라 잠시 중단 시켰던 부분입니다. 이 책은 거창하게 수학적인 개념을 코딩으로 풀어낸 것은 아닙니다. 함수형 프로그래밍의 기초를 알려주면서 부수 작용이 일어날 수밖에 없는 코드와 그렇지 않은 것을 분리하는 힘을 길러주는 책입니다. 때문에 함수형 프로그램을 맛보는 것과 동시에 기본적인 코드 구성에 대한 생각을 해볼 수 있는 책인 것 같습니다.