---
title: useEffect의 목적은 외부시스템과 동기화하기 위해서다
date: 2023-05-08
tags: ['useEffect', '리액트', '외부시스템']
image: images/useEffect의%20목적은%20외부시스템과%20동기화하기%20위해서다-20240128232621063.webp
summary: useEffect의 목적이 생명주기 관리가 아니라 외부와 동기화에 있다는 것을 설명합니다
published: true
---

리액트 공식문서에 따르면 컴포넌트가 순수해야 한다는 것을 굉장히 강조합니다. 같은 입력에는 같은 출력이 도출되어야하고, side effect가 없어야한다는 것인데요. 그런데 프로그래밍을 하다보면 side effect가 반드시 필요할 때가 있습니다. 프론트엔드에서는 통신을 하거나 이벤트 핸들러가 대표적인 side effect입니다. 프로그래밍에서 side effect를 줄이려는 시도는 예측과 다른 실행 결과를 초래할 수 있기 때문인데요. 그만큼 side effect를 잘 관리하는 것이 중요하고, 이를 관리하기 위해 제공되는 툴이 바로 `Effects` 입니다.

리액트 공식문서에서 `Effects`를 탈출구(Escape Hatches)라고 부릅니다. 왜 `Effects`가 탈출구라고 하는 것일까요? 실제 DOM을 포함하여 네트워크 통신 등 리액트 자체만으로는 해결할 수 없기 때문입니다. 따라서 리액트 외부 시스템을 조작하거나 동기화하려면 탈출구 역할을 하는 기능을 사용해야합니다. 그리고 그 기능의 대표적인 예로 `refs` 와 `Effects` 가 있습니다.

`Effects`**를 사용할 때는 주의해야 합니다. 외부 시스템과 동기화하는 목적이 아니라면 Effects 사용을 재고할 필요가 있습니다.** 또한 해당 동작이 정말 특정 값에 의존하여 동기화해야하는 것인지, 아니면 단순히 사용자 상호작용으로 이벤트 핸들러에서 처리해야하는 일인지 확인해야 합니다. 따라서 `useEffect`를 사용함에 있어 주의해야할 점을 정리하려고 합니다.

그 전에 Effect에 대해 설명하기 전에 기본적인 용어를 먼저 짚고 가려고 합니다. 리액트 훅으로 제공해주는 `useEffect` 는 세 개의 개념만 알면 됩니다. useEffect의 인자로 콜백을 받는데 그 안에 실행되는 코드를 `setup` 그리고 반환 값으로 오는 콜백을 `cleanup` 그리고 useEffect의 두 번째 인자인 배열은 `dependency array` 입니다.

- set up: 해당 컴포넌트가 처음 렌더링 되었을 때, 그리고 재렌더가 발생할 때 set up 함수를 실행합니다.
    
- clean up: 해당 컴포넌트가 다시 렌더되거나 제거될 때 실행합니다.
    
- dependency array: 의존성 배열에 포함된 값이 변해야만 clean up → set up 을 합니다. 의존성 배열을 설정하지 않은 경우 기본적으로 매번 렌더링마다 effects가 실행됩니다.
    

```
useEffect(() => {
	//1 set up...
	return () => {
		//2 clean up.
	}
}. []) //3 dependency array
```

**그리고 useEffect는 컴포넌트가 렌더된 이후에 실행한다는 점을 꼭 명심해주세요! 렌더링 중에 평가하지 않습니다!**

## useEffect는 컴포넌트의 생명주기와 다릅니다.

클래스형 리액트를 공부하신 분들은 `useEffect` 를 컴포넌트 생명주기 함수의 대체재라고 생각하실 수도 있을 것입니다. `useEffect`가 해당 역할을 대신하고 있지만, `useEffect`의 생명주기를 컴포넌트 생명주기에 빗대어 생각하는 것은 사고를 복잡하게 만듭니다. 왜냐하면 마운트, 언마운트, 재랜더 등 여러 단계로 사고해야하기 때문입니다.

공식문서에서는 `useEffect`의 생명주기를 단순하게 **시작과 중지 사이클**에만 집중하는 것을 권장하고 있습니다. 즉, 의존하고 있는 데이터에 따라 setup(시작) 하고 cleanup(중지)하기 때문에 이에 집중하여 useEffect의 동작을 예측해야한다는 것입니다.

```
useEffect(() => {
  // Your Effect connected to the room specified with **roomId**...
  const connection = createConnection(serverUrl, roomId);
  connection.connect();
  return () => {
    **// ...until it disconnected**
    connection.disconnect();
  };
}, [roomId]);
```

## 개발 모드에서 useEffect

다들 useEffect 안에 있는 로직이 제대로 작동하는지 확인하기 위해 console.log 를 찍어보신 적이 있을텐데요. `setup` 만 실행되어야할 것 같은데 실제로 그렇지 않은 걸 확인할 수 있습니다. 개발 시에는 `setup` `cleanup` `setup` 이 차례대로 호출됩니다.

이는 React의 `Strict mode` 때문입니다. 해당 설정은 컴포넌트가 순수한지 확인하기 위해 마운트/언마운트 과정을 한번 더 반복합니다. 또한 useEffect가 제대로 API 통신을 하는지, 필요한 cleanup 로직을 누락시키진 않았는지 확인해주는 역할도 합니다.

```
useEffect(() => {
  fetch('/api/buy', { method: 'POST' });
}, []);
```

따라서 만약 다음과 같이 제품을 구매하는 API 통신을 useEffect로 구현한다면, 개발 모드에서는 불필요하게 두 번 구매하는 상황이 발생한 것입니다. 이런 경우 `strict mode` 를 끄는 것이 아니라 useEffect가 정말 필요한 것인지 확인할 필요가 있습니다.

## 반응형 데이터와 의존성 배열

이제부터 useEffect 훅을 사용하는 데에 있어 버그 없이 사용하기 위한 두 가지 중요한 개념이 나옵니다. 하나는 `반응형 (의존성 배열)`이고, 다른 하나는 `핸들러와 비교` 입니다.

우선 useEffect는 반응형 데이터에 의존합니다. 컴포넌트가 렌더될 때마다 변화할 수 있는 값인데요. props 와 states 뿐만 아니라 컴포넌트 내에서 계산된 데이터 또한 변화할 수 있기 때문에 반응형 데이터입니다. 따라서 useEffect를 사용할 때 변화할 수 있는 데이터를 사용한다면, 반드시 의존성 배열에 등록을 해주어야 합니다.

그 과정에서 주의해야할 점이 두 가지가 있습니다. 첫째 **“정말 해당 반응형 데이터가 변화할 때마다 외부 시스템과 동기화를 해야하는 것인가?”** 이 물음은 반드시 useEffect를 사용하여 외부 시스템과 동기화를 해야하는데 코드를 작성하는 과정에서 불필요한 의존성이 생기는 경우가 해당됩니다. 그게 아니라면 정말 useEffect를 사용해야하는가를 한번 더 확인해보시면 좋을 것 같습니다.

둘째 **“의존성 배열에 객체와 함수가 있지 않은가?”.** 객체와 함수는 참조 타입니다. 같은 값을 갖고 있는 것 같아 보여도, 컴포넌트가 재랜더될 때마다 새로운 객체, 함수를 선언하는 경우가 많을 것입니다. 즉, 다른 객체, 다른 함수이기 때문에 불필요하게 useEffect가 반응할 것입니다.

```
function ChatRoom({ roomId }) {
  // ...
  const options = {
    serverUrl: serverUrl,
    roomId: roomId
  };

  useEffect(() => {
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [options])
```

예를 들어 해당 `useEffect` 훅은 options를 의존성 배열로 두고 있는데요. 새로운 객체를 선언하고 있기 때문에, `roomId` 가 변경되지 않았음에도 랜더링마다 `Effects` 가 일어납니다.

##  핸들러와 구분하기

마지막은 처음 보여드린 그림처럼 리액트에서 side effect를 다루는 두 가지 중 하나인 핸들러를 `Effects` 와 구분해야한다는 점입니다. 즉, 지금 사용하고 계신 `Effects` 에서 이벤트 핸들러로 처리해야할 것들이 없는지 확인해보시면 좋을 것 같습니다.

장바구니 프로그램을 예로 들어보겠습니다. 장바구니 아이템의 수량을 변경하는 stepper 컴포넌트가 있습니다. 해당 컴포넌트는 수량이 변경될 때마다 서버에 변경된 수량을 알려줘야할 것입니다. 이 경우에는 `Effects` 를 수량이라는 반응형 데이터에 의존함으로써 서버와 동기화할 수 있을 것입니다.

반면에 주문하기 버튼을 눌러 장바구니 아이템을 구매한다고 합시다. 주분하기 버튼 컴포넌트에서 버튼 클릭 시 이벤트 핸들러를 통해 서버와 통신하면 됩니다. 이럴 경우에는 굳이 `Effects` 를 사용할 필요가 없을 것입니다. 마치 아래 코드처럼요.

```
function handleClick() {
  fetch('/api/buy', { method: 'POST' });
}
```

```
useEffect(() => {
  fetch('/api/buy', { method: 'POST' });
}, []);
```

다음은 공식문서에 있는 예시입니다. 해당 `useEffect` 는 잘못된 사용 예시인데요. 이유가 무엇일까요?

우선, 개발자 모드에서 두 번의 POST가 일어나며 이는 실제 프로그램에 영향을 미치는 로직이라는 점입니다. 단순히 서버와 연결하거나 GET하는 것과는 다른 결과를 일으키는 것이죠.

근본적으로 `api/buy` 로 미루어보았을 때 구매하는 것은 렌더링에 의한 것이 아닙니다. 예를 들어, 수량을 변경하거나 input에 값을 입력하는 것처럼 렌더링과 무관한 일입니다. 구매 버튼을 누르는 등 특정 상호작용에 의해 발생되는 이벤트이기에 해당 fetch로직은 이벤트 핸들러로 옮겨 사용해야 합니다. 굳이 effect를 사용할 필요가 없는 것입니다.

`action` vs `synchoronize` 의 차이가 아닐까. 렌더링되고 있는 값에 따라 외부 시스템과 동기화해야하는 경우는 effect를 사용하는 것이 좋을 것 같습니다. 반면에 구매 버튼, 장바구니 담기 확인 버튼 등 특정 이벤트에 따라 일어나는 action 같은 경우는 굳이 effect를 사용할 필요가 없습니다.

## 그 외

1. 컴포넌트 내에 고비용 계산이 있는 경우, 특정 state나 prop이 변경될 때만 계산을 하고 싶을 수 있습니다. 이럴 때는 effect를 사용하는 것이 아니라 useMemo를 사용해주세요.
    
2. 만약 `useEffect` 에서 반응형 데이터를 사용함에도 의존성 배열에 포함시키지 않은 경우 lint 에러가 발생합니다. 여기서 반응형 데이터로는 props나 states 처럼 계속 변경될 수 있는 값, 혹은 그 값을 이용하는 모든 것을 의미합니다.