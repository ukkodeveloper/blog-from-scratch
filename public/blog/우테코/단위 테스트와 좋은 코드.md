---
title: 단위 테스트와 좋은 코드
date: 2023-04-10
tags: ['test', 'unit-test', 'e2e']
image: /images/Pasted%20image%2020240118145052.webp
summary: 테스트의 종류에 대해 생각해보고, 테스트를 해야하는 이유, 테스트로 인해 얻게 되는 것들에 대해서 정리했습니다.
published: true
---

## 테스트의 유형

![](images/Pasted%20image%2020240118145052.webp)

- Static test: 타입스크립트, eslint 등이 있다.
- Unit test: 특정 함수(기능)를 테스트하는 것이다. 물론 순수함수로 작성된 코드는 테스트하기에도 편하다. 하지만 모든 함수가 그렇진 않다. 때로는 의존하고 있는 다른 기능에 영향을 받을 수도 있다. 이 경우 의존하고 있는 함수와 함께 테스트(Sociable)를 하거나 모킹을 통해 분리하여 테스트(Solitary)를 할 수 있다.
- Integration test : 단위테스트보다 넓은 기능을 테스트한다. 경험하지 못해서 확실하게 와닿진 않지만, 전체 기능보단 작으면서, 단위테스트보다 큰 범위를 뜻한다.
- E2E test : 실제 사용자의 입장 및 환경에서 테스트하는 것이다. 사용자 플로우에 따라 전반적인 사용성을 테스트할 수 있다.

## 왜 테스트?

테스트를 하는 이유는 두 가지이다. 하나는 잘 작동하는지 확인해야하기 때문이다. 물론, 개발자가 일일이 실행해서 확인할 수 있다. 하지만 매번 그 당시 제대로 작동했는지 기억하기도 힘들다. 그리고 의존성에 의해 다른 기능 변경으로 특정 기능이 망가질 수도 있는데, 이 역시 자동화된 테스트 없이는 빠르게 확인하기 힘들다. 다른 하나는 리팩터링이다. 테스트 코드의 가장 큰 장점은 빠르게 피드백을 받을 수 있다는 점이다. 즉, 코드를 수정하면서 내가 의도했던 대로 동작하는지 확인할 수 있다.

## 테스트를 잘 하기

테스트를 잘 한다는 것은 무엇일까. 단순하게 생각해보면 어려운 함수(기능)도 테스트할 수 있으면 테스트를 잘한다고 할 수 있을까? 예를 들어, 비동기 처리를 한다거나 사이드 이펙트가 있는 함수도 테스트를 할 수 있는 능력인 것이다.

우테코 프리코스 문제에서도 Jest를 통해 `console.log` 로 출력하는 것을 테스트하는 코드가 있었다. 또한 난수 생성 시에는 `Math.random` 도 테스트를 해야 했다. 이 경우 모킹을 통해 테스트를 하였고, 심지어 테스트 코드 역시 함수로 분리하여 재사용할 수 있도록 나눠놓았다.

하지만, 정말 테스트를 잘한다는 것은 “좋은 코드”를 작성했다는 것이다. 외부 의존성과 최대한 분리하여 순수함수로 작성하면 테스트도 굉장히 쉬워진다. 즉, 모킹을 사용하거나 다른 기능과 함께 테스트할 필요 없이, 독립적으로 기능 확인이 가능하다.

## 테스트를 더 잘하기

### given - when - then으로 명확하게 구분하기

- given: 테스트를 하기 전에 사전 준비 작업을 뜻한다. 예를 들어 테스트할 메서드를 위해 인스턴스를 생성을 할 수 있다.
- when: 테스트 설명에서 “원인”에 해당하는 부분이다.
- then: 기능의 결과를 나타낸다.

### 테스트 설명은 직관적으로

가장 직관적으로 표현하는 것은 원인과 결과로 나누는 것이다. 예를 들어, “랜덤값이 4이상이면 1칸 전진한다”처럼 원인되는 상황과 그에 따른 결과를 서술한다.

### 다양한 케이스

하나의 기능을 테스트하기 위해 다양한 케이스를 생각하고 검사를 해야한다. 크게는 정상적인 케이스와 예외 케이스가 있다. 정상적인 케이스에도 “정말 정상적인 케이스”와 “엣지 케이스(양끝)”이 있을 것이다. 이러한 케이스를 모두 작성하여 미연에 생길 버그를 막을 수 있다.

## 이상한 굴레

이것은 내가 테스트를 쉽게 하기 위해 함수가 순수하도록 작성하면서 생긴 인사이트다. 약간 선순환 같은 것. 처음에는 테스트를 위해 순수함수로 작성하려고 했다. 그런데 순수함수로 만들다 보니 테스트가 반드시 필요하게 되었음을 느꼈다. 왜냐하면 함수가 의존성이 없을 수록 어디에든 사용할 가능성이 높아진다. 예를 들어, 처음에는 단순하게 랜덤값이 4이상이면 true를 반환하는 함수를 만들었다. (왜냐하면 랜덤값이 4이상일 때 전진을 하기 때문)

```jsx
function isRandomOverFour() {
  const randomNumber = Random.generate();
  return randomNumber > 4;
}
```

여기에서 Random값 때문에 순수하지 못하게 되었는데 이를 분리하니 다음과 같다. (쓰는 시점에서 생각해보니 굳이 함수로 분리할 필요가 없긴 했다.) 분리한 함수의 경우 그저 전진 조건을 확인할 때뿐만 아니라 숫자를 비교하는 모든 경우에도 사용할 수 있게 되었다. 따라서 전역적으로 사용될 여지가 있어 안정성 보장을 위해서라도 반드시 테스트를 진행해야 하는 것이다.

```jsx
function isOverNumber(num1, num2) {
  return num1 > num2;
}

isOverNumber(Random.generate(), 4);
```

결국 테스트를 잘 짜기 위해 코드를 수정했지만, 코드가 범용적으로 사용할 수 있게 되어서 정말 테스트가 필요한 굴레가 생겼다. 좋은 선순환인 것 같다.
