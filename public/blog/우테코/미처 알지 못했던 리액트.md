---
title: '미처 알지 못한 React'
date: '2023-09-10'
tags: ['리액트', 'flux' , 'life-time']
published: true
image: /images/know-react4.png
summary: '리액트를 안다고 생각했는데 몰랐습니다.'
---

리액트 라이브러리를 사용한 지 어느새 5개월 정도 되었다. 처음엔 새로운 패러다임을 이해하는 것에 급급했다. 지금은 어느정도 사용법에 익숙해졌지만, 여전히 예상과 다르게 코드가 동작하는 경험을 한다. 최근 프로젝트를 하면서 빠르게 구현만 하고 되돌아볼 시간이 부족했다. 마침 일주일동안 리액트 공식문서를 다시 읽는 스터디를 하게 되었다. 이 기회에 다시 React 핵심 개념을 정돈할 수 있었다. 머릿 속에서 흩어져 있거나 잘못 이해하고 있던 내용을 보다 뚜렷하게 할 수 있었다.

글의 목차는 '미처 알지 못했던 개념', '계속 고민하고 싶은 개념', '알쏭달쏭 신기한 경험'으로 나누었다. '미처 알지 못했던 개념'에서는 알고있다고 생각했지만 실은 잘 알지 못했던 개념들을 위주로 정리했다. '계속 고민하고 싶은 개념'에서는 개념 자체가 추상적이어서 두고두고 생각해볼 것들을 적어 놓았다.

## 미처 알지 못했던 개념

### State

***immutable***
리액트 공식문서를 읽다보면 state와 props는 불변(immutable)하다고 이야기한다. 이 부분이 이해가 되지 않았다. "불변하다"보다 "불변해야 한다."가 더 옳은 늬앙스처럼 느껴졌기 때문이다. 왜냐하면 state, props 모두 객체라면, property 조작이 가능은 하다. [immutable](https://en.wikipedia.org/wiki/Immutable_object)의 사전적 의미로도 상태 변경이 불가능한 것이라고 표현된다.
다시 읽어보니 너무 지협적인 것에 매몰되었던 것 같다. 결국 핵심은 state가 객체라면, 매번 새로운 객체로 업데이트하라는 것이다. immutable하게 state와 props를 관리하라는 정도로 이해하면 될 것 같다는 결론을 내렸다.

***key와의 관계***
react의 key라고 하면 배열에서 반드시 붙혀줘야하는 prop이라고만 생각했던 것 같다. 그리고 그 이유를 거의 암기하듯이 기억하고 있었다. 배열로 JSX 컴포넌트를 생성할 경우 배열 요소의 위치가 변경될 때마다 개별 컴포넌트 식별이 힘들다는 것만 알고 있었다.

하지만 이 기회에 key와 state와의 관계에 대해서 더 깊게 생각할 수 있었다.

![know-react1](/images/know-react1.png)

다음과 같이 A, B, C 컴포넌트를 배열로 렌더링한다고 가정하자. D와 F가 다음 렌더링에 추가가 된다면, state 관리를 할 수가 없게 된다. 왜냐하면 useState로 선언된 상태는 렌더링 순서에 따라 배열에 관리하게 된다. 따라서 배열을 순회하여 렌더링할 경우 요소의 순서가 계속 변경될 수 있고, 이 때문에 배열의 요소 컴포넌트의 상태를 매핑할 수가 없다.

![know-react2](/images/know-react2.png)

하지만 리스트 요소에 고유한 id 값인 key를 부여하면 다음과 같다. 배열의 정렬이나 개수가 변경되더라도, 배열 요소 컴포넌트가 관리하고 있는 state에 바로 매핑할 수 있는 것이다.

### 렌더링

***렌더링 과정***
공식 문서에 나온 렌더링 과정은 trigger, rendering, commit 단계로 되어있다. trigger은 상태 변경에 의해 ui를 새로 그려줘야하는 상황이 일어난 것이다. rendering은 작성된 코드를 읽으면서 React의 Virtual Dom을 생성하는 과정이다. commit은 이전 Virtual Dom과 비교하면서 React의 diffing 알고리즘을 통해 변화된 부분을 파악하고 Real Dom에 적용하는 과정을 말한다.

***리렌더링을 촉발 요인***
리렌더링을 촉발하는 요인은 state 변경밖에 없다는 것을 알게 되었다. 이전에는 특정 컴포넌트 입장에서 리렌더링되는 조건을 생각해봤을 때, 어렴풋이 props나 state가 변경될 때 리렌더된다고 생각했다. 하지만 그렇지 않다. props가 변경되지 않더라도 부모 컴포넌트의 state가 변경되면 자식 컴포넌트도 리렌더가 발생한다. 또한, props가 ref 값으로 되어 있다면, props가 변경되더라도 리렌더가 일어나지 않는다. 즉, state가 변경되었을 때만 리렌더가 일어나고 해당 컴포넌트를 기준으로 하위 컴포넌트 모두 리렌더링한다.

### Synthetic Event

React에서 Native Event를 래핑한 Event 객체다. 따라서 우리가 React 코드에서 이벤트를 붙일 때 사용하는 onClick과 같은 속성들은 사실 Synthetic Event이다. 아무래도 React 렌더링과정에서 생성되는 것이 Real DOM이 아니라 Virtual DOM이니 당연한 것일 수도 있다. Real Dom에 Virtual DOM을 붙이기 전에 특정 작업을 추가로 실행하면서 최적화를 할 수 있는데, 대표적인 예시가 이벤트를 위임하여 할당한다는 것이다.

![know-react3](/images/learn/know-react3.png)

그림과 같이 하위 컴포넌트에 있는 이벤트 핸들러를 공통된 조상 컴포넌트에 위임하여 이벤트를 등록하는 것이다. 전역 객체에 너무 많은 이벤트가 등록되는 것을 막을 수 있다는 장점이 있다. 등록된 이벤트 핸들러의 경우 전역에 할당되기 때문에 메모리 해제도 되지 않으니 깨나 매력적인 방법이라 느꼈다.

### 제어와 비제어

input을 활용한 form 컴포넌트를 만들 때 처음으로 비제어 컴포넌트를 알게 되었다. 그때는 단순히 비제어라하면 input 값을 state로 두지 않고, ref로 두는 것으로만 생각했다. 하지만 해당 경우는 단순히 여러 비제어 사례 중 하나일 뿐이었다. 즉, ref로 관리한다고 해서 비제어 컴포넌트라고 부르는 것은 틀린 것이었다.

비제어 컴포넌트는 상위 컴포넌트의 제어에서 벗어난 컴포넌트를 말한다. (모든 것은 상대적이니, 주체를 명확히 정하는 것이 중요하다.) 특정 컴포넌트가 상위 컴포넌트의 상태에 영향을 받는다면 제어 컴포넌트, 그렇지 않다면 비제어 컴포넌트이다.

### 생명주기

***useEffect***
클래스로 컴포넌트를 작성할 때에는 생명주기 메서드를 굉장히 많이 지원을 했다. 그리고 함수형 컴포넌트로 변경되고 나서부터 컴포넌트 생명주기에 따라 useEffect로만 제어한다고 생각했다.

하지만 useEffect는 컴포넌트 생명주기를 관리하기 위한 훅이 아님을 알게 되었다. 물론 렌더링 중에 useEffect가 실행되기 때문에 컴포넌트의 생명주기에 영향을 받는 것은 사실이다. 그럼에도 useEffect는 독자적인 생명주기를 갖고 있다. 자신에게 등록된 의존성 배열에 따라 setup하고 cleanup한다.

***Ref***
Ref는 컴포넌트 생명주기와 매우 밀접한 관련이 있다. Ref는 렌더링 과정중에 참조가 일어난다. 따라서 만약 DOM을 참조하는 Ref가 있다면, 해당 Ref는 이미 붙어있는 Real DOM을 참조하게 된다. 이게 중요한 것은, 리렌더 상황 시에 Ref가 무얼 참조하고 있는 지 알아야하기 때문이다.

![know-react4](/images/know-react4.png)

다음 그림은 상태가 변경되는 과정이다. 상태가 변경되고 리렌더가 일어나는데, 만약 컴포넌트에서 Ref를 사용한다면, 변경되기 이전 DOM에 참조가 된다. 따라서 흔히 Ref를 이용한 로직을 useEffect안에 두어 사용한다. 그렇게되면 변경된 Ref가 DOM에 참조가 이어진 상태에서 연산이 일어나기 때문이다.

***Ref callback***
하지만 굳이 ref + useEffect 조합을 사용하지 않아도 된다. ref callback을 사용하면 렌더링 후 Real DOM에 커밋된 이후에 ref 참조가 이뤄진다. 단, 래렌더할때마다 렌더링 중에는 ref가 참조를 하지않아 `undefined`가 된다. 따라서 반드시 조건문으로 `undefined`가 아님을 걸러줘야 한다.

## 계속 고민하고 싶은 개념

### 컴포넌트

***선언적***
흔히 React를 선언적인 UI컴포넌트를 만드는 라이브러리라고 한다. 선언적이라는 말은 무엇일까. How보다는 What을 나타내는 것이라고 생각하면 쉽다. 축복과 같은 JSX 덕분에 우리는 컴포넌트에서 return으로 JSX 요소를 반환하기만 하면 된다.

바닐라 자바스크립트에서는 DOM을 직접 생성, 접근, 추가해줘야했다. 이러한 일련의 명령적인 코드를 JSX로 어떤 모양의 컴포넌트를 렌더할 것인지 정의만 해주면 된다.

때문에 React를 쓰다보면 우리가 직접 DOM을 조작하지도 않았는데 마치 마법처럼 반영되는 것을 경험할 수 있다. 하지만 "선언적"이라는 말 속에는 누군가가 알아서 "명령적"으로 복잡한 일들을 처리한다는 뜻이기도 하다. 즉, React는 우리에게 선언적으로 사용할 수 있도록 API를 제공해주는 것이고, 실제 복잡한 일들을 React가 알아서 처리를 해준다.

![know-react5](/images/know-react5.png)

해당 사진은 React팀에서 발표한 컨퍼런스 자료 중 일부이다. MVC패턴에서 생긴 복잡성을 어떻게 React가 FLUX 패턴을 사용하여 해결했는 지 잘 나타내는 그림이다. 우선 React는 렌더링 과정이 단방향이다. 초기 렌더 혹은 유저 상호작용을 통해 Action이 발동(setState)되면 Dispatcher에서 관리하고 있는 데이터(state)를 변경시키고 해당 데이터를 바탕으로 View를 그려주는 방식이다.

React가 선언적일 수 있는 이유는, Dispatcher 에서 Store 그리고, View를 그려주는 과정을 React에서 알아서 해준다. 대신에 우리는 View와 Action에 집중하여 프로그래밍을 할 수 있다. View는 JSX로 표현된 컴포넌트일 것이고, Action은 렌더링 연산으로 주로 Hook과 관련된 내용일 것이다.

***colocate***
바로 위에서 React를 사용하면 View와 Action에 집중할 수 있다고 했는데, 이는 colocate 개념에서도 드러난다.

과거에는 HTML, CSS와 JavaScript를 기능이 다르다 하여 분리하였다. HTML은 뼈대이고, CSS는 스타일링이고, JavaScript는 로직이니 해당 분리도 타당하다. 하지만 그때는 맞았지만 지금은 틀리다. 그때는 데이터를 보여주는 용도로 웹이 사용되었고 사용자 상호 작용이 많지 않았다.

반면에 현재는 웹을 앱이라 말할 정도로 사용자 상호 작용이 많다. 매 상호작용마다 UI를 변경해주어야 한다. 즉, 이 둘은 매우 밀접한 관계를 갖게 되었다. 더 이상 기능의 분리는 의미가 없어졌고, `컴포넌트 별 관심사`로 분리할 필요가 생겼다. 따라서 React는 UI와 로직을 한 데 두는 방식으로 컴포넌트를 정의하는 형식을 채택한 것으로 보인다.

### 사이드 이펙트

***순수함수***
순수함수란 외부 상태를 변경하지 않고 동일한 인자에 대해 동일한 결과를 반환하는 함수를 말한다. 리액트 공식문서에 따르면, 리액트 컴포넌트를 순수하게 작성하라는 말이 굉장히 많이 나오는데, 리액트에서 순수성이란 무엇일까.

여러 번 컴포넌트를 재렌더하더라도 외부에 영향이 없어야 하고, 항상 같은 ui를 보여줘야 한다. 따라서 `React.StrictMode`에서는 렌더링을 의도적으로 한번 더 함으로써 순수성을 확인시켜 줍니다.

***Effect 와 Ref***
하지만, 우리는 UI를 다루기 때문에 모든 것을 순수하게 컴포넌트를 작성할 수는 없습니다. 때로는 외부와 통신을 해야하고, setTimeout과 같이 Web API를 이용하여 UI에 반영하기도 해야합니다. 또한 유저 상호작용이라는 외부적 요소에 영향을 받아 새로 UI를 그려줘야 하기도 합니다. 즉,  `side effect` 가 발생할 수 밖에 없습니다.

리액트에서는 이러한 side effect를 효과적으로 다룰 수 있는 몇 가지 방법을 제시합니다. 우선 유저 상호작용의 경우는 바닐라 자바스크립트처럼 event handler를 사용하면 됩니다. 또한 외부 시스템과 동기화하려면 useEffect를 사용할 수 있습니다. 그리고 Real DOM에 접근하여 작업이 필요한 경우에는 Ref를 사용할 수 있을 것입니다.

참고로 Effect와 Ref는 리액트의 탈출구라고 부르기도 합니다. 그만큼 리액트의 제어에서 벗어나 별도로 동작하는 행위입니다. 따라서 정말 필요한 경우에만 사용해야합니다. Effect를 잘못 사용한 예시를 들어보겠습니다. useEffect에 반응형 값에 따라 결제하는 POST 요청을 넣을 수도 있을 것입니다. post 요청이 side effect도 맞으며, 반응형 값에 따라 연쇄적으로 해당 로직을 수행하는 게 이상하지 않을 수도 있습니다. 하지만 해당 로직은 충분히 event handler로 옮길 수 있습니다. 심지어 Effect를 사용하면 첫 렌더링 시에 한번 수행하기 때문에 예상치 못한 요청이 발생할 수 있습니다. 해당 예시처럼 결제라는 유저에게 영향을 크게 미치는 요청이라면 문제가 심각할 것입니다. 또한, 개발모드에서 StrictMode에 따라 useEffect를 의도적으로 한 번 더 실행하기 때문에 개발 중일 때에도 예상치 못한 작업이 발생할 수 있습니다.

## 끝으로

확실히 우테코 크루들과 함께 리액트 공식문서를 보고 이야기를 나누면서 기반이 더 단단해진 것 같다. 어렴풋이 알고 있었던 내용도 있었고, 잘못 이해하고 있었던 내용도 있었다. 특히 useEffect 같은 경우는 온갖 버그가 발생할 수 있는 훅인 만큼 서로의 경험과 side effect에 대한 생각을 공유할 수 있어서 좋았다.

추가로 리액트 공식 문서 LEARN REACT에 나오지만 아직 작성해보지 못한 것들도 있다. 예를 들면 `useSyncExternalStore`m, `flusSync` 그리고 아직 정식 API는 아닌 `useEffectEvnet` 등이 있다.  다행히 이번 기회에 어떤 훅인지 확인할 수 있었고 왜 필요한 지 알게 되었다. 앞으로 필요할 때 사용해봐도 괜찮을 것 같다.