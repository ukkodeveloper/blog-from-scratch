---
title: 프론트엔드 성능 최적화
date: 2023-09-28
tags: ['성능-최적화']
image: /images/프론트엔드%20성능%20최적화-20240128171741870.webp
summary: 프론트엔드 성능 최적화에 대한 기본 지식들을 공유합니다. s-hook 프로젝트에 직접 적용한 내용도 포함되었습니다.
published: true
---

## 프론트엔드 성능 최적화란?

 과거에는 클라이언트에서 성능이 부담되는 경우가 많지 않았다. 하지만, 웹에서 하는 일이 많아지고 다양한 이미지나 영상들이 포함되고, interaction을 위한 자바스크립트 번들 사이즈도 커졌다. 

그러다보니 로딩 시간이 너무 길어지는 경우를 종종 겪었을 것이다. 지금도 몇몇 앱이나 웹에만 들어가면 오랜 시간 기다려야해서 못 참고 꺼버린 적이 한두번이 아니다.

[핀터레스트 성능 최적화](https://medium.com/dev-channel/a-pinterest-progressive-web-app-performance-case-study-3bd6ed2e6154) 글은 굉장히 유명하다. 자바스크립트 번들 최소화, 라우트별 코드 스플리팅, 이미지 지연 로딩 등을 통해 개선한 사례다. 해당 작업 결과 사용 시간이 기존 모바일 웹 사이트 대비 40% 증가했고, 광고 수익이 44%, 핵심 엔게이지먼트가 60% 증가했다.

따라서 잘 알려져 있는 성능 최적화하는 방법에 대해서 알아보고, 현재 프로젝트에서 무얼 적용했는지 소개하려 한다.

## 로딩 최적화
### 소스코드

과거에 비해 SPA 유행과 함께 자바스크립트 코드의 용량이 굉장히 커졌다. 자바스크립트를 로딩하는 과정 자체에서 병목이 될 수 있다. 

실제로 실습을 통해 확인한 바로는, 트리 쉐이킹과 css minify만 해주어도 2.42MB 에서 228KB로 현격히 줄어들 수 있다.

![](images/프론트엔드%20성능%20최적화-20240128171741870.webp)

이미 우리에게 많은 도구가 제공된다. 웹팩이라면 terser plugin이 존재한다. 웹팩 5를 포함해서 롤업과 같은 최신 번들러의 경우는 기본으로 자동으로 트리쉐이킹을 하여 최적화를 한다. 

본인은 웹팩 5버전을 사용하였고, production 환경에서는 기본으로 terser plugin이 작동한다. 대신에 우리 입장에서 신경 써 줘야할 부분이 있다. 페이지 내에서 사용하지 않는 모듈을 로딩에 포함되지 않도록 모듈을 잘 나누고 필요한 부분만 사용하는 것이다. 모달과 같이 당장 사용하지 않는 내용물은 [react lazy](https://react.dev/reference/react/lazy) api 를 사용하여 지연 import를 적용할 수도 있다.

css 파일도 minify하는 플러그인이 존재한다. ([css-minimizer-webpack-plugin](https://github.com/webpack-contrib/css-minimizer-webpack-plugin)) 그러나 css 자체가 js에 비해 로딩할 용량이 현저히 적기도 하고, 만약 css-in-js를 사용한다면 더더욱 성능 개선을 체감할 수 없긴 하다.

### 이미지

이미지 최적화는 정말 필수 중의 필수다. 일단 웹에서 많이 사용하기도 하며, 용량도 크기 때문이다. 

이미지 최적화의 핵심은 최소 손실로 최대 압축을 하는 것이다. 가장 좋은 방식은 jpg 대신 다른 포맷을 사용하는 것이다. png의 경우 jpeg에 비해 5배 이상 용량이 적다. webp의 경우 png보다도 26% 용량을 줄일 수 있는 포맷이다. ([webp](https://developers.google.com/speed/webp#:~:text=WebP%20is%20a%20modern%20image,in%20size%20compared%20to%20PNGs.)) 그러나 항상 생소한 포맷은 현재 서비스에서 제공하는 브라우저 범위에서 사용 가능한 지 확인해봐야 한다.
그럼에도 여전히 용량이 크다면 resize할 필요가 있다. 실제 렌더링되는 크기의 2배 정도가 적당하다. 왜냐하면 레티나 디스플레이는 표준이미지 크기의 2배의 크기가 필요하기 때문이다.

하지만... 우리는 대부분 반응형 웹을 만들고 있지 않은가? 그렇다면 디바이스 해상도에 맞게 이미지 크기를 다르게 제공해줄 수 있다. (이를 [responsvie image](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images)라 한다.) img 태그의 srcset 속성을 이용하는 것이다.

이는 반응형 이미지를 미리 만들어 놓아야 한다는 의미이기도 하다. 직접 이미지를 해상도별 사이즈에 맞게 asset에 추가하여 빌드하는 방법이 있다. 이미지가 적다면 이렇게 해도 무방할 것 같다. 이미지가 조금이라도 많다면, webpack에 [responsive-loader](https://www.npmjs.com/package/responsive-loader)를 사용하면 빌드시에 반응형 이미지를 생성할 수 있다. 그리고 가장 손 쉬운 방법은 aws s3를 통해 정적 데이터를 관리한다면, 자동으로 해준다!

### 동영상, 폰트

동영상과 폰트는 각자 프로젝트 성향에 따라 너무 달라서 각자 상황에 맞는 방법을 찾는 것이 중요할 것 같다. 기본적인 것만 언급을 하자면...

동영상의 경우 역시 포맷 변경만으로 많은 개선을 이룰 수 있다. gif보단 mp4, mp4보다는 webm이 압출률이 더 좋다. 다만, 역시 지원하는 브라우저 범위를 잘 확인해야 한다.

폰트의 경우는 사용하지 않는 subset을 제거하는 것이 좋다. 특히 다국어를 지원하는 서비스의 경우 폰트가 굉장히 많기 때문에 작은 것 개선을 미친다. 또한 폰트는 단순히 용량만으로는 개선 수치를 모두 표현할 수 없다. 왜냐하면 load 우선순위가 높아야 하는 자원이기 때문이다. 

재밌는 [일화](https://www.zachleat.com/web/mitt-romney-webfont-problem/)가 있다. 뉴스 기사의 제목에서 not만 다른 폰트를 사용하고 있었다. 그런데 해당 폰트 로딩이 길어지는 바람에 "not"만 보이지 않았던 문제다. 따라서 원래는 '대선에 출마하지 않는다' 인데, '대선에 출마한다' 로 보여서 파장이 컸다는 내용이다.

조금 더 설명하자면, 해당 글은 사실 FOIT과 FOUT을 메인으로 다룬 글이다. FOIT의 경우 폰트가 로드 되기 전에 공백으로 두는 것이고, FOUT은 기본 폰트라도 보여주는 방식이다. 즉, 해당 일화는 FOIT이었기 때문에 "not"이 보이지 않았던 것이다. 하지만, FOIT이 만능은 아닌 것이, 기본 폰트에서 지정한 폰트로 변경될 때 레이아웃이 변경된다. 어쨌든 폰트는 빨리 로드되어 빨리 적용되어야 하는 중요한 자원이다.

폰트 역시 개선된 포맷이 존재한다. TTF와 OTF 에 비해 WOFF, WOFF보다는 WOFF2가 압출률이 좋다. 하지만, 이 역시 지원 가능한지 확인하여 사용해야 한다.

## 렌더링 최적화

렌더링 최적화는 다행히 로딩 최적화에 비해서 신경 쓸 부분이 적긴하다. 그래서 간단하게 짚고 넘어가려고 한다.


### layout shift

layout shift는 로드 중이거나 그 이후에 레이아웃이 변경되는 현상이다. 즉, 짧은 시간에 화면이 뚝 끊겨서 변경되니 당연히 UX에 좋지도 않고, 다시 layout을 계산하니 성능에도 좋지 못하다.

해당 이슈는 생각보다 쉽게 해결할 수 있다. chrome의 lighthouse 도구를 통해 성능 측정을하면 layout shift가 일어나는 곳을 알려주고, 해결 방법을 잘 알려주기 때문이다.

예를 들면, 이미지의 width와 heght가 지정되어 있지 않은 경우 직접 명시해야한다는 것이 예시다.

유저 상호작용 과정에서도 layout shift가 일어날 수도 있다. 예를 들면 css 스타일링을 통해 왼쪽에서 오른쪽으로 서서히 이동하게 만들었다고 하자. position을 속성을 이용하면 매순간 레이아웃니 변경되기 때문에 reflowrk 발생한다. 따라서, transform을 사용해서 합성 단계에서만 재계산될 수 있도록 최적화할 수도 있다.

### react

React 최적화라고 하면 memo를 아마 가장 먼저 생각난다. 하지만 우리 Dan 형님의 조언 대로 memo를 사용하기 전에 정말 react 구조를 제대로 설계 했는지 먼저 확인하는 것이 우선일 듯 하다. ([해당글](https://overreacted.io/before-you-memo/))

## 우리 프로젝트 최적화하기

현재 서비스중인 S-HOOK의 프로젝트를 최적화하기 위해서는 앞서 말했던 것보다 더 중요한 부분이 있었다. S-HOOK 은 youtube player api를 사용한다. 상하 스와이프를 통해 노래를 탐색할 수 있는데, 첫 로딩에서 노래 개수만큼 스크립트가 병렬로 로드 된다.

사실, 해당 스크립트는 한번만 로드하면 캐싱되기 때문에 추가 로드되지 않아도 되는데, 한번에 노래 개수만큼 렌더링하도록 되어 있던 게 화근이었다.

따라서 intersectionObserver을 이용하여 동적으로 youtube player을 로드할 수 있도록 변경했다.

#### 개선 전
![](images/프론트엔드%20최적화-20240128151201694.webp)

개선 전엔 수많은 스크립트가 로드된다. 이 때문에 Total Blocking Time이 32,050ms 이 소요되었다.

#### 개선 후
![](images/프론트엔드%20성능%20최적화-20240128184813647.webp)
개선 후에는 이전과 비교했을 때 엄청난 개선을 이뤘다는 것을 알 수 있다. TBT도 1,320ms 도 현격히 많이 줄었다.

## 끝으로

성능 최적화할 수 있는 방법들을 찾아보고, 실습도 해보면서 느낀 가장 중요한 것은 "필요한 최적화"를 해야한다는 것이다. 글 앞부분에 수많은 최적화 방법들을 소개했지만, 결국 정말 필요한 최적화 부분은 youtube player 을 어떻게 동적으로 로드하는 것이었다. 

블로그 글에 설명은 하나씩 간단하게 설명했지만, 막상 프로젝트에 적용하려면 쉽지 않은 부분도 있다. 어떤 플러그인을 써야 하는지, 적용했는데 생각치도 못한 사이드 이펙트가 있을 때도 있었다. 결국 이 모든 작업이 리소스인 것이다. 결국 최적화도 여느 작업과 마찬가지로 문제를 정확하게 정의하는 것이 가장 중요하다는 것을 또한번 느낄 수 있었다.


