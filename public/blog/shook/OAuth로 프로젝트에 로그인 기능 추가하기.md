---
title: 'OAuth로 프로젝트에 로그인 기능 추가하기'
date: '2023-10-14'
tags: ['oauth', '로그인', '토큰']
image: '/images/oauth1.webp'
summary: '백엔드와 함께 Oauth를 협업하는 과정에서, 프론트엔드에서 고민했던 것들을 적었습니다.'
published: true
---

## 왜 Oauth를 도입했는가

### 왜 Oauth인가

서비스 개발 과정에서 로그인이 필요해졌다. 유저의 플레이리스트를 저장해야하고, 중복 등록을 막아야 하기 때문이다. 로그인 정책에도 여러 방식이 있다. 자체 인증 과정을 만들 수도 있으며, 구글과 카카오 같은 플랫폼을 통해 인증하는 방법도 있다. 우리 기술 수준에서는 자체적으로 보안을 철저하게 지킬 수 없다는 판단을 했다. 사용자는 보통 같은 아이디와 비밀번호를 사용하는 경우가 많다. 따라서 **만약 우리 서비스로부터 사용자 정보가 해킹당한다면, 다른 사이트에서도 해킹될 수 있는 가능성이 높다.** 현재 팀의 기술 수준으로 보았을 때 보안을 철저하게 지킬 수 없다 생각하여 Oauth를 통해 거대 플랫폼에 위임하는 방식이 낫다고 판단하였다.

### Oauth

Oauth란 사용자의 접근 권한을 제 3자에게 위임하는 프로토콜이다.

![Oauth1](/images/oauth1.webp)

Oauth의 플로우는 다음과 같다. 위 그림에서 Client는 백엔드를 가르키고, Authorization Server는 구글이나 카카오의 인증서버다. Client(백엔드)에서 인증 요청을 보내고 유효할 경우 Access Token과 Refresh Token을 받게 된다. 그리고 인증이 필요할 때 Resource 서버에 요청을 하여 Access Token이 유효한 지 확인할 수 있으며 만료 응답이 올 수도 있다. 만료 응답이 올 경우 Refresh Token을 Authorization에 보내어 갱신된 새로운 Access Token을 받을 수 있다.

### 로그인 과정

위의 Oauth 플로우는 서버(인증 클라이언트)와 인증 서버와의 플로우다. 이번에는 우리 서비스의 Client와 Server와의 플로우를 확인해보면 다음과 같다.

![Oauth2](/images/oauth2.webp)

1. 클라이언트에서 카카오나 구글에서 제공해주는 Oauth 인증 페이지로 리다이렉트시켜준다.
2. 해당 페이지에서 유저가 로그인을 하면 지정해준 리다이렉트 페이지에 인증 코드가 담긴 URL을 보내준다.
3. 클라이언트에서 인증 코드를 받아서 서버에 요청을 보낸다.
4. 서버는 카카오나 구글에 인증 코드를 보내준다.
5. 카카오나 구글에서 인증 코드를 확인 후에 유효하면 access token을 보내준다.
6. 서버에서 해당 access token을 확인한 후에 자체적으로 access token을 다시 만든다. **이때 주의할 점은 전자의 access token은 카카오나 구글에 대한 인증 정보를 담은 토큰이고, 후자는 서버에 대한 인증 정보를 담은 토큰이다. 그리고 서버는 클라이언트에게 응답으로 access token을 담아 보낸다.**

## Refresh 토큰

### Refresh token이 필요한 이유

refresh token이 필요한 이유는 다소 복합적이다. 우선, access token만으로 인증 처리를 했을 때의 문제를 생각해야 한다. access token의 만료 기간을 짧게 설정할 경우 보안에는 유리하지만 사용자에게 로그인 요청을 자주해야한다. 그 과정에서 사용자 경험이 낮아질 수 밖에 없다. 그렇다고 access token의 만료 기간을 길게 설정하면 보안에 큰 문제가 생긴다.

이러한 문제를 개선할 수 있는 장치가 refresh token이다. 보안 이유로 access token의 유효 기간을 짧게 두면서도 사용자에게 불편함을 주지 않게 할 수 있다. **access token이 만료 될 때마다 토큰 재발급 요청을 보내주어 불필요한 로그인 과정 없이 access token을 재발급해줄 수 있기 때문이다.**

### 보안 처리

**그렇다면 refresh token이 탈취된다면?** Oauth 프로토콜에 따르면 refresh token만으로 access token을 발급해준다. 이 방식을 그대로 프로젝트에 도입한다면, 보안에 문제가 생긴다. 서버에서 access token을 회원별로 저장하고 있지 않다. 따라서 refresh token이 탈취된다면 access token이 무한히 발급될 수 있다.

따라서 우리가 내린 결정은 access token을 갱신할 때 access token과 refresh token을 함께 보내는 것이다. 서버는 refresh token마다 최근에 발급된 access token을 매핑하고 있다. 클라이언트에서 access token과 refresh token을 함께 보내면 서버는 매핑이 제대로 되어 있는 지 확인을 한다.

의문이 들 수도 있다. refresh token만으로 인증하는 것과 별 차이가 없어보일 수 있다. 왜냐하면 해커가 refresh token이 탈취했다는 것은 access token도 탈취했을 가능성이 높기 때문이다. (shook 서비스에서도 access token은 local storage에, refresh token은 httpOnly, secure 속성을 준 cookie로 저장한다. )

하지만 access token과 refresh token을 함께 인증했을 때 이점이 있다. 첫째, 다수의 해커가 동시에 악용할 수 없다. refresh token이 최근 발급받은 access token하고만 매핑되어 있기 때문이다. 둘째, 매핑된 access token이 아닌 부적절한 토큰으로 요청을 보냈을 때, 해당 refresh token을 무효화할 수 있다. 더 이상 해당 refresh token으로 요청된 재발급 자체를 막을 수 있기 때문이다. 그렇다면 이제 해커가 refresh token을 탈취했다고 하더라도, 본래 유저가 재발급 요청을 했다면 해커는 access token이 만료될 때까지만 사용할 수 있는 것이다.

추가로 이렇게 token 방식으로 인증 정보를 처리할 때 보안에 신경쓴다고 해서 session으로 관리하는 것보다 안전하진 않다. 현재 프로젝트 서버에서 유저의 개인정보를 따로 저장하고 있지 않고, 민감한 정보를 다루지 않고 있다. 보안에 불안정한 과정에서 최대한 보안을 고려했다고 보면 될 것 같다.

## 프론트엔드 고민 사항

### access token 저장 위치

이미 어느정도 전체적인 Oauth 흐름과 틀이 정해졌다. 그렇다면 클라이언트 입장에서 Oauth를 어떻게 다뤄야할 지 정해야할 차례이다. (이미 앞에서 스포가 되었지만,) 클라이언트에서 access token은 어디에 저장을 해야할까.

고민한 선택지는 총 네 가지이다. 인메모리, 쿠키, 세션스토리지, 로컬스토리지.

- 인메모리: 탈취에서 매우 안전한 방식이다. 하지만 이미 로그인된 사용자가 새로고침하면 access token은 사라진다. 매번 refresh 요청을 보내야한다. 만약 페이지별 쿼리 요청이 많다면, 추가로 요청을 보내야한다는 것이 부담일 수 있다. 또한 팀에서 내린 결정으로는 refresh token만으로 access token을 갱신할 수 없기 때문에 적절치 않은 방식이다.
- 세션스토리지: 인메모리의 하위 호환이다. 인메모리에서 언급한 문제를 그대로 가지면서도 탈취에 취약하다는 단점이 있다.
- 쿠키: httponly 속성을 사용할 경우 javascript로 쿠키에 접근할 수 없다. access token은 jwt로 렌더링에 필요한 닉네임 정보가 들어있기 때문에 적절치 않다고 생각했다.
- 로컬스토리지: javascript로 언제든 접근 가능하다. 그러나 javascript로 접근이 가능하기 때문에 XSS 공격으로부터 자유로울 수 없는 단점을 갖고 있다.

인메모리와 세션스토리지를 제외하고, 쿠키와 로컬 스토리지를 비교했을 때 보안적으로 큰 차이를 느끼지 못하였다. cookie의 경우 모든 요청에 추가되어지기 때문에, **로컬 스토리지를 선택했다.**

### refresh token 저장 위치

refresh token은 탈취가 되지 않도록 보안적으로 더 신경을 써야 한다. 따라서 **httponly, secure 속성이 추가된 쿠키로 관리**했다. 그러나 쿠키의 경우 모든 요청에 추가되는 문제가 있다. 때문에 쿠키를 도메인 하위 경로에만 저장을 하도록 하였다. **즉, 해당 엔드포인트로 요청할 때에만 쿠키가 담기도록 설정한 것이다.**

### access token 만료 확인

보통은 서버에서 acces token을 파싱하여 만료되었는 지 확인한다. 하지만 jwt로 구현되어 있어 프론트엔드에서 토큰을 확인하고 만료를 검증할 수 있다. access token 자체가 브라우저 local storage에 담겨져 있어 사실상 로그인 정보가 클라이언트에서 관리할 경우가 많다. 이러한 점에서 서버 뿐만 아니라 프론트에서도 access token 만료를 검증하기로 결정했다. 요청을 보내기 전에 검증하면 좋은 점은 access token이 만료되었음을 서버로부터 받지 않아도 되기 때문에 요청의 수를 줄일 수 있다.

하지만 요청마다 jwt 파싱하는 비용이 발생한다. 문자열을 파싱하는 것이 비용이 크다고 생각하진 않는다. 그럼에도 매번 파싱하는 것보다 access token과 파싱한 값을 인메모리로 캐싱하기로 결정했다.

## 프론트엔드 Oauth 적용

### 사용자별 경우의 수

로그인이 도입된 이후 사용자 경우의 수가 굉장히 많아졌다. access token, refresh token을 기준으로 여러 상태가 있고 이를 고려해야하기 때문이다.

| access token | refresh token | 결과                |
| ------------ | ------------- | ------------------- |
| 유효         | -             | 본 요청 / 인증 성공 |

| 기간 만료X
but, 회원 정보가 틀린 경우 (탈퇴 등으로 인하여) | 유효 | 본 요청 / 401 |
| 기간 만료 | 유효 | 갱신 요청 / 인증 성공
본 요청 / 인증 성공 |
| 기간 만료 | 기간 만료 및 유효 X | 갱신 요청 / 401 |

이를 그림으로 그리면 다음과 같다.
![Oauth3](/images/oauth3.webp)

### 401 에러 처리

인증 에러 시에 어떻게 처리를 해주어야할 지에도 많은 고민이 있었다. 바로 로그인 페이지로 이동시키는 방법도 있을 수 있고, 모달을 통해 로그인을 유도할 수도 있다. shook 서비스에서는 ‘좋아요’에는 로그인이 필요하다. 하지만, 다른 서비스를 보았을 때 그렇지 않은 서비스도 종종 있다. 즉, 유저 입장에서 좋아요 클릭이 반드시 로그인이 필요하다는 걸 인지하지 못 한 채 버튼을 누를 수 있다. 이 때 바로 로그인 페이지로 이동한다면 유저가 당황할 수도 있을 것이다. 이를 방지하기 위해 로그인을 유도하는 모달을 띄워주는 방식을 채택했다.

처음에는 401시에 에러를 순차적으로 throw하여 Error Boundary를 통해 모달을 띄우려고 했다. 하지만 문제가 있었다.

```tsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  render() {
    if (this.state.hasError) {
      return (
        <a>
          {this.props.children}
          <LoginModal />
        </a>
      );
    }

    return this.props.children;
  }
}
```

첫째, 스크롤이 처음 진입점으로 가지는 문제가 발생한다.

![Oauth4](/images/oauth4.webp)

shook 서비스에는 스와이프 형식으로 노래를 보여준다. 페이지 진입점으로 부터 스와이프 후에 인증이 필요한 상호작용이 발생하고 Error Bounday에서 이를 감지한 후 자식 컴포넌트를 다시 랜더링을 한다. 이 과정에서 자식 컴포넌트를 완전히 다시 코드를 읽고 렌더링하게 된다. 그 과정에서 스크롤이 페이지 진입점으로 이동한다.

둘째, 자식 컴포넌트에서 랜더링하는 동안 실행되는 모든 요청이 다시 실행된다. 이유는 위와 같다.

따라서 fetch를 사용하는 hook에서 `try…catch…` 를 사용하여 에러를 잡고 로그인 모달을 렌더링하는 방식을 택했다. 문제가 있다면 fetch를 사용하는 hook이 로그인 모달에서 사용하는 상태를 의존하게 되었다는 점이다. 이 둘의 레이어를 분리할 수 있는 방법은 추후에 더 찾아봐야할 것 같다.

## 끝으로

로그인이라고 하면 백엔드에서 대부분 처리를 하고 클라이언트에서는 요청만 보내주면 되는 것이라고 생각했다. 하지만 로그인이 도입된 이후 많은 부분에서 분기가 생겼다. 예를 들면 UI의 경우 로그인된 사용자와 그렇지 않은 사용자를 나눠야 했다. 또한 요청을 보낼 때에도 access token을 확인하고, 만료일 때 처리도 추가해주어야 했다. 뿐만 아니라 요청 시 인증 실패에 대한 에러 핸들링도 포함되어 있어야 했다. 마지막으로 로컬 스토리지를 사용하면서 토큰을 가져오고 수정하는 등의 작업을 하는 객체를 별도로 분리해야 했다.

짧은 시간동안 백엔드와 로그인을 함께 구현하면서 토의도 많이하고, 여러 이슈들도 많이 직면했다. 전체적인 로그인 흐름을 결정하는 것도 많은 시간이 소비되었지만, 실제 구현하는 것은 한 차원 더 힘든 일이라는 것을 새삼 깨닫게 되었다. 또한 프론트엔드 측면에서는 앞서 말했듯 로그인 기능이 프로그램 전반에 영향을 끼치는 것이기 때문에 확인하고 또 확인하는 과정을 반복했다. 아직 배포중인 프로덕션에 로그인 기능이 추가된 지 얼마 안되어 또 어떤 버그가 일어날 지는 모르겠지만 현재까지는 버그 없이 잘 진행되는 것 같다.

### 참고

- https://hudi.blog/oauth-2.0/
- https://developer.okta.com/blog/2019/10/21/illustrated-guide-to-oauth-and-oidc
- https://tansfil.tistory.com/59
- https://www.youtube.com/watch?v=hm2r6LtUbk8
