---
title: 이제부터 스크롤하세요
date: 2023-11-02
tags:
  - ux
  - 리액트
image: /images/Jan-28-2024%2014-22-41.gif
summary: 섬세한 조절이 필요한 UI에 스크롤이 도입했습니다. 그 과정에서 필요했던 지식들을 공유합니다.
published: true
---
## 슬라이더가 너무 불편해요

우리가 만들고 있는 S-HOOK (슉) 서비스는 노래마다 자신만의 킬링파트를 등록하고 공유할 수 있다. 모바일 이용자를 타겟으로 만들어졌으며, 킬링파트를 등록하는 UX가 상당히 중요하다.

그런데 킬링파트를 등록하는 데 불편하다는 피드백이 많아졌다. 본인 개인적으로 사용했을 때는 킬링파트 구간이 1, 2초 차이 나는 건 별로 신경이 안 쓰였지만, 사용자는 그게 아니었다. 슬라이더를 통해 시간을 지정하다 보니 생각보다 섬세하게 작동이 안하는 것이다.

![](images/이제부터-20240125153538688.webp)

모바일 너비의 절대적 크기가 제한적이다 보니 이를 어떻게 해결할 수 있을지 고민이었다. 팀원들과 긴 시간동안 회의를 했고, 인스타그램의 스토리 올리는 UI에 착안하여 '스크롤'해서 킬링파트 구간을 선택할 수 있도록 결정했다. 그래서 나온 결과물은 다음과 같다.![](images/Jan-28-2024%2014-22-41.gif)

## UI 설명

우선, 구체적인 구현을 설명하기 전에 UI에 대한 전반적인 설명이 필요할 것 같다.
![](images/이제부터%20스크롤%20하세요!-20240127182940001.webp)

킬링파트를 등록하기 위해 필요한 정보는 '시작 시간'과 '구간 길이'다. 시작 시간은 0초부터 (곡의 길이 - 구간길이) 만큼 가능하다. 구간 길이는 5초부터 15초까지 설정할 수 있다.

1번 UI로 킬링파트 구간 길이를 변경할 수 있다. 2번은 킬링 파트를 등록하기 전에 임시 저장하는 역할이며, 명칭은 '핀'으로 설명하겠다. 3번은 슬라이더에서 스크롤로 변경된 UI다. 좌우 스크롤을 통해 시작 시간을 조절할 수 있다.  그리고 그 안에 작은 박스는 킬링파트 구간을 나타낸다. 이를 킬링파트 구간 박스라고 부르겠다.

## 개발 

### 스크롤 너비 계산하기

계산에 앞서 스크롤 너비를 변동시킬 것인지부터 고려해야 한다. 만약 변동 시킬 것이라면, 뷰포트의 너비나 곡의 길이에 따라 너비를 다르게 할 수도 있다. 스크롤 너비가 충분히 길다고 생각하여서 곡의 길이에만 따라서 스크롤 길이를 동적으로 변동하도록 설정하였다.

그리고 이제 스크롤 가능한 영역을 선택해야 한다. 스크롤 좌우에 패딩을 주지 않으면 웨이브 UI가 킬링파트 구간 박스를 넘어가서 존재하게 된다. 마치 첫 번째 그림처럼 말이다.
![](images/이제부터%20스크롤%20하세요!-20240128123920190.webp)


따라서 곡의 시작과 끝에는 스크롤이 넘어가지 않도로 패딩을 줘야 한다. 마치 두 번째, 세 번째 사진처럼 말이다. 이를 위해서 패딩값을 계산해야 하는데, 전체 너비에서 킬링파트 구간 너비만큼 뺀 길이를 왼쪽 오른쪽 절반씩 패딩값 설정을 하면 된다.

여기서 중요한 점은 킬링파트 구간 박스는 동적이다. 5~15초로 구간을 지정할 수 있기 때문에 동적으로 길이가 변동된다. 그렇다면 구간이 변동될 때마다 패딩 값을 재설정 해줘야한다는 것을 알 수 있다.

이 뿐만이 아니다. 반응형 웹을 지원하기 때문에 전체 너비가 변동될 수 있다. 이는 resize observer을 활용해서 너비가 변경될 때마다 패딩 값을 재설정해주면 된다.

### 짤막 스타일링

사실 위에 부분이 핵심이고, 지금 말할 스타일링은 짤막 팁에 가깝다. 

#### 정중앙에 위치하기

킬링파트 구간 박스가 전체 너비에 중앙에 위치하는 방법이다. 
![](images/이제부터%20스크롤%20하세요!-20240128124919289.webp)

left 50%를 주면, 부모 요소 맨 왼쪽으로 부터 **부모 너비의 50%** 만큼 왼쪽으로 이동하여 위치하게 된다. 여기에서 translateX 를 -50%를 해주어야한다. 해당 속성은 **자기 너비의 50%** 만큼 왼쪽으로 위치시킨다. 그러면 부모 요소의 정중앙에 위치하게 된다.


#### 차오르는 progress 구현하기

![](images/이제부터%20스크롤%20하세요!-20240128125058118.webp)
킬링파트 구간이 10초면, 10초동안 구간 박스가 점점 왼쪽에서 오른쪽으로 차오르는 UI다. 이는 background 속성을 이용하여 구현할 수 있다. background를 2배로 늘린다음, linear-gradient 속성을 통해 왼쪽은 핑크색, 오른쪽은 투명하게 채운다. 그리고 킬링파트 시간만큼 왼쪽에서 오른쪽으로 이동하게끔 하면 된다. 

만약 반복재생 중이라면 animation을 infinite로 설정하면 계속 반복하여 애니메이션이 진행된다. 


### 데이터 흐름 파악하기

갑자기 스크롤 UI 설명하면서 데이터 흐름 이야기하니까 다소 이상하게 느껴진다. 본인도 처음에는 UI만 신경쓰면 될 줄 알았다. 하지만 생각보다 React 상태와 사이드 이펙트를 처리하는 방법이 까다로웠다.

처음엔 구간 변경은 구간 길이 상태만 변경 시키고, 스크롤 이동이나 핀을 통한 시작점 이동은 시작 시간 상태만 변경하면 된다고 생각했다.

하지만, 유저 상호작용을 통해 React 상태뿐만 아니라 곧바로 스크롤도 변경해야하는 상호작용도 존재했다. 대표적으로 임시 저장한 킬링파트 구간을 클릭하면 시작 시간이 이동해야하는데, 동시에 스크롤도 변경되어야 한다.

이렇게 설계 없이 1차원적으로 구현하다보면 흐름을 찾기 힘들고 서로가 서로에게 영향을 미치게 된다. 여기에 더해 debouncing도 적절한 의존성 설정을 하지 않으면 코드를 짠 자신도 왜 이런 결과가 나오는 지 모르는 지경에 이른다.

복잡한 데이터흐름을 단순화한 그림은 다음과 같다.
![](images/이제부터%20스크롤%20하세요!-20240128133937595.webp)

스크롤 하다보면 유튜브를 너무 많이 조작해야하는 경우를 대비해서 debouncing을 걸었다. 구간 길이와 시작 시간 상태가 UI에 영향을 미치기 때문에, UI는 바로 반영되고, 유튜브 플레이어는 딜레이를 주는 형식으로 취해야한다. 

또한 스크롤 위치를 반드시 관리해야한다. 모든 유저 상호작용의 창구 역할을 하는 것이 스크롤이다. 즉, 킬링파트 구간이나 시작 시간은 결국엔 스크롤 위치에 의해 변경되어야 한다. 왜냐하면 스크롤 위치와 킬링파트 정보가 모두 동기화되어야 하기 때문이다.

## 끝으로

정말 어려운 작업이었다. 사실, 이 모든 기획이 처음부터 다 짜여진 것은 아니었다. 기능을 만들고 피드백 받고 수정하기를 5번 넘게 진행하면서 만들었다. 그렇다보니 처음엔 맞아 보이는 것들이 수정하면서 틀렸다는 것을 알게 되었다. 대표적으로 동기화 때문에 스크롤 위치가 외부 시스템과의 창구 역할을 하고 있었다는 점이다. 

또 어느 부분은 내가 알고 있던 안티 패턴을 사용해서라도 구현할 수밖에 없던 부분도 있었다. 공식문서에 따르면 React 상태 변경에 반응하여 다른 상태 변경을 일으키면 안된다. 하지만 그렇게 하지 않으면 데이터 흐름이 매우 지저분해진다. 차선책이라도 적용하자는 마음으로 안티 패턴을 사용했다.

아쉬운 것은 차치하고 팀에서 문제 해결을 위해 함께 고민하고 기획하여 개선했다는 점에서 뿌듯한 경험이었다. 실제로 사용자 피드백으로 등록 과정이 재밌어졌다는 의견을 많이 받았다. 그리고 개발 역량에서도 많이 성장할 수 있었다. 사이드 이펙트, UI와 데이터가 강결합 되어있는 형태까지 경험했다. 복잡할수록 주먹구구식 구현보다는 큰 그림을 짜면서 구현할 필요성을 다시 한번 느꼈다.