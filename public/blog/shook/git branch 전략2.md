---
title: 'OAuth로 프로젝트 로그인 기능 추가하기1'
date: '2010-4-2'
tags: ['우테코', 'react',]
image: '/images/oauth1.png'
summary: '안녕하세요 UKKO입니다. 이거슨 예시입니다.'
published: true
---
# git branch 전략이 필요한 이유

팀에서 프로젝트를 한다면 버전관리가 필수다. 내가 작업하는 내용과 다른 사람이 작업하는 내용이 다르며, 이 둘이 어떻게 서로 영향을 줄 지 모르기 때문이다. 따라서 이를 브랜치로 나누어서 버전관리를 한다. 즉, 충돌을 방지하고 안정적으로 소프트웨어 개발을 보장하는 것이다.

git branch 전략에는 여러가지가 있다. 가장 대표적인 전략으로는 git-flow와 github-flow가 있다. 이 둘이 유명하다고 해서 반드시 정답인 것은 아니다. 프로젝트의 규모나 성격에 따라 완전히 달라질 수 있다. 한 예로 모바일 앱 같은 경우 배포 버전을 모두 신경을 써주어야 한다. 하지만 웹의 경우 항상 최신 버전만이 배포되어 있기 때문에 최신 버전 중심으로 버전을 관리해야 한다.

프로젝트 초반이기도 하고, 아직 개발 서버도 없기 때문에 모든 앞 일을 예상할 수는 없다. 하지만 여러 전략을 찾아보고 우리에게 적합한 전략은 무엇인지 토론하는 시간을 가졌다. 그리고 간단한 데모를 통해서 우리가 선택한 전략의 장점은 무엇이고 치명적인 부분은 무엇인지 확인할 수 있었다.

# git branch 전략

## 1️⃣ git-flow

### 설명

git-flow에서 설명하자면 크게 develop 브랜치와 master 브랜치로 구분된다. master 브랜치는 배포하고 있는 브랜치이며, develop 브랜치는 완료된 기능들을 모아둔 브랜치이다. 즉, develop 브랜치는 master 브랜치로 가기 전 임시로 저장되어 있는 형태이다. 그림을 보면 더 이해하기 쉬울 것이다.
![](images/git%20branch%20전략-20240118150657130.webp)

이제 이 핵심 두 브랜치 develop과 master에서 어떤 파생 브랜치들이 생기는 지 보면 된다. master 브랜치에서는 hotfixes 브랜치가 파생된다. 이름에서 알 수 있듯, 이는 급하게 수정되어야 하는 버그 수정 브랜치이다. 따라서 develop이 아닌 master에서 분기되어야 한다. 그리고 hot fix가 되었다면 develop과 master 모두 반영해주어야 한다.

develop 브랜치에서 파생된 브랜치는 feature 브랜치다. 기능 개발을 위한 브랜치이다. 기능이 완료되면 브랜치를 develop 브랜치에 병합한다. 그리고 master로 배포하기 전에 거쳐하는 브랜치가 release이다. 출시 하기 전에 QA를 하기 위한 브랜치이다.

### git-flow를 선택하다!

우리 S-HOOK 프로젝트에서는 처음에 git-flow를 채택했다. 이유는 조금 부실했지만 모두가 무지랭이였기 때문에 그 때는 매우 타당한 이유였다. 첫째, 우테코 내 20명 정도의 크루들이 함께 하고 있는 프롤로그라는 프로젝트도 git-flow를 사용하고 있다. 그리고 그 중 2명이 우리 프로젝트에 있어서 해당 전략을 잘 인지하고 있다. 둘째, 가장 견고해보인다. 다음에 설명하겠지만 git-flow는 너무 단순해보인다. 그에 반해 git-flow는 매우 짜임새 있고 소프트웨어를 정말 체계적으로 관리하는 듯한 느낌을 준다.

### git-flow 문제

하지만 간단한 데모를 통해 브랜치 전략을 테스트를 해보는 시간에서 문제를 인지했다. 첫째, develop브랜치에 이미 feature 브랜치가 붙는다면 선택적으로 기능을 배포할 수 없다는 점이다. 예를 들어, develop 브랜치에 A기능, B기능, C기능이 순차적으로 병합되었다고 가정하자. 만약 급하게 A기능은 제외하고 B와 C기능만 master 브랜치에 추가하여 배포하고 싶을 수도 있다. 하지만 현재 구조에서는 이를 해결하려면 엄청나게 복잡도가 올라간다. 둘째, 우리에겐 release branch가 필요 없다. 왜냐하면 전문 QA도 없을 뿐더러 주기적으로 배포하는 그런 체계적인 시스템이 갖춰져있지 않기 때문이다.

## 2️⃣ git-flow를 변형하자

그래서 생각한 방법은 git-flow를 우리 마음대로 뜯어 고치자는 것이다. 두 번째 문제로 나왔던 release branch를 삭제하는 것은 그리 어려운 일이 아니었다. 그리고 그게 우리팀에게 매우 합리적인 선택이라고 생각했다. 문제는 첫 번째 문제였다.

정말 열띈 논쟁이 벌여졌고 모든 feature 브랜치를 master 브랜치에서 파생시키는 방법으로 결정되었다. 마치 버그는 아니지만 당장 master에 붙어야하는 기능들을 고려한 결정이었다. 이름은 feature브랜치이지만 언제나 hot feature 브랜치가 될 수 있다고나 할까.

### 문제

역시나 문제가 있다. (뭐 어느 선택이든 문제가 있겠지만.) feature 브랜치를 병합할 때마다 우리는 develop에 붙여야 하는지, master에 붙여야 하는지, develop과 master에 동시에 붙여야하는지 명확하지 않다는 것이다. 만약 개발하고 있는 기능의 특징에 따라 구분할 수 있다면 그나마 다행이다. 하지만 이는 기획이나 여러 상황에 맞게 유동적으로 정해질 수 있는 사안이라 더 혼란을 가중시킬 수 있다.

## 2️⃣ github-flow

### 설명

![](images/git%20branch%20전략-20240118150750543.webp)
사진부터 git-flow와는 비교도 안되게 단순하다는 것을 알 수 있다. 기능 구현할 것이 있으면 branch를 파생해서 개발하면 된다. 그런 다음 그 브랜치에서 개발 서버를 연결하여 충분히 QA를 진행하는 것이다. 그런 다음 배포 시기에 필요한 기능이라면 master에 merge하여 배포할 수 있다.

이러한 점은 git-flow의 여러 문제를 해결해준다. 우선, 변형된 git-flow에서 생겼던 병합 시에 생기는 다양한 선택지와 그로 인해 발생되는 복잡도가 해결된다. 그리고 git-flow를 변형할 수 밖에 없었던 이유였던 develop 브랜치에서 선택적으로 기능을 배포하는 일도 해결된다. 왜냐하면, 만약 당장 필요하지 않을 것 같은 기능은 개발이 완료되어도 master에 병합되지 않기 때문이다. 그대로 브랜치를 살려두면 된다.

### 단점

대부분 github-flow의 단점은 프로젝트가 커졌을 때 문제가 된다. feature가 QA 후에 master에 붙여질 수 있다는 것이 병목이 된다. 왜냐하면 QA할 때마다 최신 master 버전을 rebase를 해주어야 하며 기능 하나씩 QA가 진행되기 때문이다. 또한 기능은 완성되었지만 아직 master에 병합되지 못한 브랜치들을 관리하기가 어렵다. 이러한 단점은 반대로 소규모 프로젝트에서 정말 최적화되어있다는 점을 반증하기도 한다.

# 끝으로

여러 git branch 전략을 파악하고 우리 입맛에 바꿔보면서 생기는 장단점들을 파악했다. 그 과정에서 예상치 못한 문제들을 접하며 그때마다 우리에게 최적인 전략을 찾으려고 노력했다. 처음에는 그저 유명하고 체계적으로 보인다는 이유로 git-flow를 채택했다. 하지만 여러가지 단점인 상황을 해결하는 과정에서 우리에게 정말 필요한 전략을 찾을 수 있었다. 그리고 그 이유를 명확하게 설명할 수 있게 되었다.

### 출처

- [https://techblog.woowahan.com/2553/](https://techblog.woowahan.com/2553/)
- [https://blog.hwahae.co.kr/all/tech/9507](https://blog.hwahae.co.kr/all/tech/9507)
- [https://cjw-awdsd.tistory.com/49](https://cjw-awdsd.tistory.com/49)